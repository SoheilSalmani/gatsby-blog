---
title: Customizing the GraphQL Schema
resourceId: https://www.gatsbyjs.com/docs/reference/graphql-data-layer/schema-customization/
stoppedAt: Foreign-key fields
---

Gatsby is able to automatically infer a GraphQL Schema from your data, and in
many cases, this is really all you need. There are however situations when you
either want to explicitly define the data shape, or add custom functionality to
the query layer - this is what Gatsby’s Schema Customization API provides.

## Explicitly defining data types

```md nu fp=src/data/post1.md
---
title: Sample Post
publishedAt: 2019-04-01
author: jane@example.com
tags:
  - wow
---

# Heading

Text
```

```json nu fp=src/data/author.json
[
  {
    "name": "Doe",
    "firstName": "Jane",
    "email": "jane@example.com",
    "joinedAt": "2018-01-01"
  }
]
```

```json nu fp=src/data/contributor.json
[
  {
    "name": "Doe",
    "firstName": "Zoe",
    "email": "zoe@example.com",
    "receivedSwag": true
  }
]
```

Plugins: `gatsby-source-filesystem`, `gatsby-transformer-remark`,
`gatsby-transformer-json`.

### The Node interface

This data structure is represented in Gatsby’s GraphQL schema with the `Node`
interface, which describes the set of fields common to node objects created by
source and transformer plugins. In GraphQL Schema Definition Language (SDL), it
looks like this:

```graphql
interface Node {
  id: ID!
  parent: Node!
  children: [Node!]!
  internal: Internal!
}

type Internal {
  type: String!
}
```

For example, the node type created by gatsby-transformer-json for authors.json
will be represented in the GraphQL schema as:

```graphql
type AuthorJson implements Node {
  id: ID!
  parent: Node!
  children: [Node!]!
  internal: Internal!
  name: String
  firstName: String
  email: String
  joinedAt: Date
}
```

### Automatic type inference

It’s important to note that the data in `author.json` does not provide type
information of the Author fields by itself. In order to translate the data shape
into GraphQL type definitions, Gatsby has to inspect the contents of every field
and check its type. In many cases this works very well and it is still the
default mechanism for creating a GraphQL schema.

2 problems:

- It is quite time-consuming and therefore does not scale very well.
- If the values on a field are of different types Gatsby cannot decide which one
  is the correct one. A consequence of this is that if your data sources change,
  type inference could suddenly fail.

Both problems can be solved by providing explicit type definitions for Gatsby’s
GraphQL schema.

### Creating type definitions

Assume a new author joins the team, but in the new author entry there is a typo
on the `joinedAt` field: “201-04-02” which is not a valid Date.

This will confuse Gatsby’s type inference since the joinedAt field will now have
both Date and String values.

#### Fixing field types

To ensure that the field will always be of Date type, you can provide explicit
type definitions to Gatsby with the createTypes action. It accepts type
definitions in GraphQL Schema Definition Language:

```js fp=gatsby-node.js
exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions
  const typeDefs = `
    type AuthorJson implements Node {
      joinedAt: Date
    }
  `
  createTypes(typeDefs)
}
```

Note that the rest of the fields (`name`, `firstName`, etc.) don’t have to be
provided, they will still be handled by Gatsby’s type inference.

#### Opting out of type inference

There are however advantages to providing full definitions for a node type, and
bypassing the type inference mechanism altogether. With smaller scale projects
inference is usually not a performance problem, but as projects grow the
performance penalty of having to check each field type will become noticeable.

Gatsby allows to opt out of inference with the `@dontInfer` type directive -
which in turn requires that you explicitly provide type definitions for all
fields that should be available for querying:

```js fp=gatsby-node.js
exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions
  const typeDefs = `
    type AuthorJson implements Node @dontInfer {
      name: String!
      firstName: String!
      email: String!
      joinedAt: Date
    }
  `
  createTypes(typeDefs)
}
```

Note that you don’t need to explicitly provide the Node interface fields (`id`,
`parent`,` etc.), Gatsby will automatically add them for you.

#### Defining media types

You can specify the media types handled by a node type using the `@mimeTypes`
extension:

```graphql
type Markdown implements Node
  @mimeTypes(types: ["text/markdown", "text/x-markdown"]) {
  id: ID!
}
```

#### Defining child relations

The `@childOf` extension can be used to explicitly define what node types or
media types a node is a child of and immediately add `child[MyType]` and
`children[MyType]` fields on the parent.

The types argument takes an array of strings and determines what node types the
node is a child of:

```graphql
# Adds `childMdx` as a field of `File` and `Markdown` nodes
type Mdx implements Node @childOf(types: ["File", "Markdown"]) {
  id: ID!
}
```

The mimeTypes argument takes an array of strings and determines what media types
the node is a child of:

```graphql
# Adds `childMdx` as a child of any node type with the `@mimeTypes` set to "text/markdown" or "text/x-markdown"
type Mdx implements Node
  @childOf(mimeTypes: ["text/markdown", "text/x-markdown"]) {
  id: ID!
}
```

The `mimeTypes` and `types` arguments can be combined as follows:

```graphql
# Adds `childMdx` as a child to `File` nodes *and* nodes with `@mimeTypes` set to "text/markdown" or "text/x-markdown"
type Mdx implements Node
  @childOf(types: ["File"], mimeTypes: ["text/markdown", "text/x-markdown"]) {
  id: ID!
}
```

#### Nested types

So far, the example project has only been dealing with scalar values (`String`
and `Date`; GraphQL also knows `ID`, `Int`, `Float`, `Boolean` and `JSON`).
Fields can however also contain complex object values. To target those fields in
GraphQL SDL, you can provide a full type definition for the nested type, which
can be arbitrarily named (as long as the name is unique in the schema). In the
example project, the frontmatter field on the MarkdownRemark node type is a good
example. Say you want to ensure that frontmatter.tags will always be an array of
strings.

```graphql
exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions
  const typeDefs = `
    type MarkdownRemark implements Node {
      frontmatter: Frontmatter
    }
    type Frontmatter {
      tags: [String!]!
    }
  `
  createTypes(typeDefs)
}
```

Note that with `createTypes` you cannot directly target a `Frontmatter` type
without also specifying that this is the type of the `frontmatter` field on the
`MarkdownRemark` type, The following would fail because Gatsby would have no way
of knowing which field the `Frontmatter` type should be applied to:

```graphql
exports.createSchemaCustomization = ({ actions }) => {
  const { createTypes } = actions
  const typeDefs = `
    # This will fail!!!
    type Frontmatter {
      tags: [String]!
    }
  `
  createTypes(typeDefs)
}
```

It is useful to think about your data, and the corresponding GraphQL schema, by
always starting from the Node types created by source and transformer plugins.

**Note:** The `Frontmatter` type must not implement the Node interface since it
is not a top-level type created by source or transformer plugins: it has no `id`
field, and is there to describe the data shape on a nested field.

#### Gatsby Type Builders

In many cases, GraphQL SDL provides a succinct way to provide type definitions
for your schema. If however you need more flexibility, `createTypes` also
accepts type definitions provided with the help of Gatsby Type Builders, which
are more flexible than SDL syntax but less verbose than `graphql-js`. They are
accessible on the `schema` argument passed to Node APIs.

```js fp=gatsby-node.js
exports.createSchemaCustomization = ({ actions, schema }) => {
  const { createTypes } = actions
  const typeDefs = [
    schema.buildObjectType({
      name: "ContributorJson",
      fields: {
        name: "String!",
        firstName: "String!",
        email: "String!",
        receivedSwag: {
          type: "Boolean",
          resolve: source => source.receivedSwag || false,
        },
      },
      interfaces: ["Node"],
    }),
  ]
  createTypes(typeDefs)
}
```

Gatsby Type Builders allow referencing types as simple strings, and accept full
field configs (`type`, `args`, `resolve`). When defining top-level types, don’t
forget to pass `interfaces: ['Node']`, which does the same for Type Builders as
adding `implements Node` does for SDL-defined types. It is also possible to opt
out of type inference with Type Builders by setting the `infer` type extension
to `false`:

```diff
schema.buildObjectType({
  name: "ContributorJson",
  fields: {
    name: "String!",
  },
  interfaces: ["Node"],
+ extensions: {
+   // While in SDL you have two different directives, @infer and @dontInfer to
+   // control inference behavior, Gatsby Type Builders take a single `infer`
+   // extension which accepts a Boolean
+   infer: false
+ },
}),
```

Type Builders also exist for Input, Interface and Union types: `buildInputType`,
`buildInterfaceType`, and `buildUnionType`. Note that the `createTypes` action
also accepts `graphql-js` types directly, but usually either SDL or Type
Builders are the better alternatives.

#### Foreign-key fields

#### Extensions and directives

#### Setting default field values

#### Creating custom extensions

## createResolvers API

### Accessing Gatsby’s data store from field resolvers

### Custom query fields

### Taking care of hot reloading

## Custom Interfaces and Unions

### Queryable interfaces

## Extending third-party types

### Feeding remote images into gatsby-image
