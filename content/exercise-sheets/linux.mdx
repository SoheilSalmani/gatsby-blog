---
title: Linux
relatedResources: []
tags: []
---

## Linux in Action

1. What is a distribution?

   <Solution>

   A _distribution_ (sometimes shortened to _distro_) is a customized stack of
   software that’s packaged along with the Linux kernel and distributed with
   tools for installing a working version of Linux of user computers.

   </Solution>

2. Describe how a file system works.

   <Solution>

   You can think of a file system as a data table (or an index) that creates
   apparent connections between individual files and groups of files with
   identifiable locations on a disk. A file system uses such an index to provide
   the appearance of an organized set of directories and files within a single
   disk division known as a _partition_.

   </Solution>

3. What is the most commonly used Linux file system.

   <Solution>The most commonly used Linux file system is ext4.</Solution>

4. Describe the role of each Linux top-level directory.

   <Solution>

   <Figure src="/media/linux-top-level-directories.png">
     Common top-level directories as defined by the UNIX FHS.
   </Figure>

   </Solution>

## The Linux Programming Interface

1. What are the two meanings of _operating system_?

   <Solution>

   The term _operating system_ is commonly used with two different meanings:

   - To denote the entire package consisting of the central software managing a
     computer’s resources and all of the accompanying standard software tools,
     such as command-line interpreters, graphical user interfaces, file
     utilities, and editors.
   - More narrowly, to refer to the central software that manages and allocates
     computer resources (i.e., the CPU, RAM, and devices).

   The term _kernel_ is often used as a synonym for the second meaning.

   </Solution>

2. Where the Linux kernel typically resides?

   <Solution>

   The Linux kernel executable typically resides at the pathname
   `/boot/vmlinuz`.

   </Solution>

3. What are the tasks performed by the kernel?

   <Solution>

   - _Process sceduling_: A computer has one or more central processing units
     (CPUs), which execute the instructions of programs. Like other UNIX
     systems, Linux is a _preemptive multitasking_ operating system,
     _Multitasking_ means that multiple processes (i.e., running programs) can
     simultaneously reside in memory and each may receive use of the CPU(s).
     _Preemptive_ means that the rules governing which processes receive use of
     the CPU and for how long are determined by the kernel process scheduler
     (rather than by the processes themselves).

   - _Memory management_: While computer memories are enormous by the standards
     of a decade or two ago, the size of software has also correspondingly
     grown, so that physical memory (RAM) remains a limited resource that the
     kernel must share among processes in an equitable and efficient fashion.
     Like most modern operating systems, Linux employs virtual memory
     management, a technique that confers two main advantages:

     - Processes are isolated from one another and from the kernel, so that one
       process can’t read or modify the memory of another process or the kernel.
     - Only part of a process needs to be kept in memory, thereby lowering the
       memory requirements of each process and allowing more processes to be
       held in RAM simultaneously. This leads to better CPU utilization, since
       it increases the likelihood that, at any moment in time, there is at
       least one process that the CPU(s) can execute.

   - _Provision of a file system_: The kernel provides a file system on disk,
     allowing files to be created, retrieved, updated, deleted, and so on.

   - _Creation and termination of processes_: The kernel can load a new program
     into memory, providing it with the resources (e.g., CPU, memory, and access
     to files) that it needs in order to run. Such an instance of a running
     program is termed a _process_. Once a process has completed execution, the
     kernel ensures that the resources it uses are freed for subsequent reuse by
     later programs.
   - _Access to devices_: The devices (mice, monitors, keyboards, disk and tape
     drives, and so on) attached to a computer allow communication of
     information between the computer and the outside world, permitting input,
     output, or both. The kernel provides programs with an interface that
     standardizes and simplifies access to devices, while at the same time
     arbitrating access by multiple processes to each device.
   - _Networking:_: The kernel transmits and receives network messages (packets)
     on behalf of user processes. This task includes routing of network packets
     to the target system.
   - _Provision of a system call application programming interface (API)_:
     Processes can request the kernel to perform various tasks using kernel
     entry points known as _system calls_. The Linux system call API is the
     primary topic of this book.

   In addition to the above features, multiuser operating systems such as Linux
   generally provide users with the abstraction of a _virtual private computer_;
   that is, each user can log on to the system and operate largely independently
   of other users.

   </Solution>

4. Describe what user mode and kernel mode are?

   <Solution>

   Modern processor architectures typically allow the CPU to operate in at least
   two different modes: _user mode_ and _kernel mode_ (sometimes also referred
   to as _supervisor mode_). Hardware instructions allow switching from one mode
   to the other. Correspondingly, areas of virtual memory can be marked as being
   part of _user space_ or _kernel space_. When running in user mode, the CPU
   can access only memory that is marked as being in user space; attempts to
   access memory in kernel space result in a hardware exception. When running in
   kernel mode, the CPU can access both user and kernel memory space.

   Certain operations can be performed only while the processor is operating in
   kernel mode. Examples include executing the halt instruction to stop the
   system, accessing the memory-management hardware, and initiating device I/O
   operations. By taking advantage of this hardware design to place the
   operating system in kernel space, operating system implementers can ensure
   that user processes are not able to access the instructions and data
   structures of the kernel, or to perform operations that would adversely
   affect the operation of the system.

   </Solution>
